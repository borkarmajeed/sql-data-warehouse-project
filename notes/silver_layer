## BUILDING SILVER LAYER
STEP 1: Analyising 
  Explore & understand the Data  

STEP 2: Coding
  Data Cleansing
    1) Check quality of bronze
    2) Write data transformation
    3) Insert into silver

STEP 3: Validating
  Data correctness checks

STEP 4: Docs & Version
  Data documenting versioning in GIT

  ------------------------------
  CRM TABLES Exploration

  crm_cust_info -->      Customer Information,                  primary key: cst_id
  crm_prd_info -->       Product current & history Information, primary key: prd_id
  crm_sales_details -->  Sales transactions                     primary key: prd_id

  similarly for ERP tables,
  Then made DATA INTEGRATION (table relationship diagram) 

==============================================================================================================================
==========================================CREATE DDL FOR SILVER LAYER=========================================================

Metadata Columns: Extra columns added by the data engineers that do not originate from the source data.
Examples :
create_date: the record's load timestamp
update_date: the recird's last update timestamp
source_system: the origin system of the record

to make ddl script for silver just copied existing bronze's ddl script and replace bronze with silver.
but here in silver layer, we are creating some extra columns (metadata columns)
Examples: given naminf convention for self created columns --> [dwh_create_date] - to see the record's load timestamp
current datetime will be capture under [dwh_create_date] column.

--------------------Table--------------Clean & load crm_cust_info--------------------------------------

STEP 1: checks for NULLs or DUPLICATES in PRIMARY KEY
EXPECTATIONS: No results
-----------------------------------------------------

Explanation: we will remove NULLs & DUPLICATES while moving from bronze to silver
-- Query to analyse duplicates & NULLs
        SELECT cst_id,
        COUNT(*)
        FROM bronze.crm_cust_info
        GROUP BY cst_id
        HAVING COUNT(*) > 1 OR cst_id IS NULL;

-- analyse one by one DUPLICATE PRIMARY KEYs 
        SELECT *
        FROM bronze.crm_cust_info
        WHERE 
        cst_id = 29466;
Explaination: here we found that recods having different cst_create_date so we are only keeping latest date record
and removing old date record.

-- Query to identify duplicate record and filter only latest.
        SELECT * 
        FROM
        	(SELECT *,
        	ROW_NUMBER() OVER (PARTITION BY cst_id ORDER BY cst_create_date DESC) AS flag_last
        	FROM bronze.crm_cust_info
        	WHERE cst_id IS NOT NULL)t
        WHERE flag_last = 1;

Explaination: we have partitioned based on cst_id and order by based on cst_create_date and assigned row_number based on cst_create_date 
i.e. we have given rank to DUPLICATES and filetered only LATEST record

STEP 2: check for unwanted spaces
EXPECTATIONS: No results
-----------------------------------------------------
Explaination: check for columns like [cst_firstname], [cst_lastname], [cst_marital_status]

-- Query to identify if spaces presents for cst_firstname
        SELECT cst_firstname,
        LEN(cst_firstname) AS len1, -- this column just to see len differences
        LEN(TRIM(cst_firstname)) AS len2 -- this column just to see len differences
        FROM bronze.crm_cust_info
        WHERE cst_firstname != TRIM(cst_firstname);

-- Query to identify if spaces presents for cst_firstname
        SELECT cst_lastname,
        LEN(cst_lastname) AS len1, -- this column just to see len differences
        LEN(TRIM(cst_lastname)) AS len2 -- this column just to see len differences
        FROM bronze.crm_cust_info
        WHERE cst_lastname != TRIM(cst_lastname);

-- Query to identify if spaces presents for cst_gndr
        SELECT cst_gndr,
        LEN(cst_gndr) AS len1, -- this column just to see len differences
        LEN(TRIM(cst_gndr)) AS len2 -- this column just to see len differences
        FROM bronze.crm_cust_info
        WHERE cst_gndr != TRIM(cst_gndr);
Explaination: if the original alue is not equal to the same value after trimming, it means there are spaces

STEP 3: data standardization & consistency
EXPECTATIONS: In our datawarehouse, we aim to store clear & meaningful values rather than abbreviated terms
-----------------------------------------------------
Explainantion: check for [cst_gndr] & [cst_marital_status]

        SELECT DISTINCT
        cst_gndr
        FROM bronze.crm_cust_info
Explainantion: there are Three values in cst_gndr column NULL, M & F
so we: If 'F' then make it 'Female'
       If 'M' then make it 'Male'
       If NULL then make it 'n/a'
-- Query to make above requirements -- this query will work in MAIN QUERY
		CASE WHEN UPPER(TRIM(cst_gndr)) = 'M' THEN 'Male'
			 WHEN UPPER(TRIM(cst_gndr)) = 'F' THEN 'Female'
			 ELSE 'n/a'
		END cst_gndr,
Explainantion: also we ensure and take care of any space and lowercase

--  [cst_marital_status] --> M - Married & S - Single
		CASE WHEN UPPER(TRIM(cst_marital_status)) = 'M' THEN 'Married'
			 WHEN UPPER(TRIM(cst_marital_status)) = 'S' THEN 'Single'
			 ELSE 'n/a'
		END cst_marital_status,

STEP 3: nothing need to do with cst_create_date column
---------------------------------------------------------

STEP 4: inserting clean data into silver.crm_cust_info
-------------------------------------------------------



